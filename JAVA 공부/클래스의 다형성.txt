오버로딩
: 같은 이름의 메서드들 중에 매개변수의 타입 및 개수의 차이에 따라 구분하여 사용할 수 있게 하는 것
ex)
void method(){System.out.println("operation1");}		// 해당 두 메서드는 각 기 다른 코드를 품을 수 있다.
void method(int a){System.out.println("operation2");}

오버라이딩
: 부모가 갖는 메소드를 자식 클래스에서 재정의하는 것, 상속과 비슷하지만 다른 개념
(부모에 존재하는 같은 이름을 가진 메소드들을 재정의하는 것)
ex)
class Parent{
	public void print(){System.out.println("P");}
}
class Child extends Parent{
	public void print(){System.out.prinln("C");}
}
Child c = new Child();
c.print;		// 결과는 C로, 부모의 메서드를 상속받음에 있어서 같은 이름의 메서드가 존재하면,
		// 상속받은 상속자의 메서드 우선순위를 높게 할당하므로써, 상속자의 메소드를 호출하게 된다.

캡슐화
: 멤버 변수 및 멤버 함수(메서드)를 원하는 범위 외의 접근에는 숨김으로써 안정성을 높이는 것
ex)
public, protected, private 접근지정자를 활용하여, 원하는 곳에서만 접근을 허락한다.
public : 모든 곳에서 접근가능
protected : 멤버 변수나 메서드가 선언되는 클래스 및 상속 클래스 내에서만 한정적으로 접근가능
private : 선언되는 클래스에서만 접근가능

다형성
: 부모가 갖는 참조변수로 여러 하위 타입(자식)의 인스턴스들을 받아들일 수 있는 것
(부모, 자식에 같은 이름의 멤버 변수가 있을 경우)
1. 자식 클래스 참조변수에 자식 클래스의 인스턴스를 넣을 경우, 자식 클래스에 선언된 멤버 변수가 사용된다.
2. 부모 클래스 참조변수에 자식 클래스의 인스턴스를 넣을 경우, 부모 클래스에 선언된 멤버 변수가 사용된다.
(같은 이름의 멤버 변수가 아닐 경우)
상속의 의미로, 부모멤버 변수를 자식 인스턴스에서 받아들인다.

ex)
Parent p = new Child();
참조변수    인스턴스(객체) 

- 참조
https://devroy.tistory.com/30

** 클래스의 상속이란? **
: 확장은 가능하지만 축소는 불가능하다.
그렇기에 부모참조변수가 가진 멤버변수의 양보다 자식인스턴스의 멤버변수의 개수가 많으므로 다형성을 이용할 때, 확장을 하여 받아드리지만,
자식참조변수가 부모인스턴스를 받아들이는 것은 부모 참조변수의 멤버변수의 개수가 더 적으므로 축소를 사용해야 한다.
하지만 클래스 특성상 축소는 허가되지 않으므로, 자식 참조변수로는 부모 인스턴스를 받아들일 수 없다.

- 참조
http://www.tcpschool.com/java/java_polymorphism_concept